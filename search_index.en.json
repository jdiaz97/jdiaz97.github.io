[{"url":"https://jdiaz97.github.io/projects/","title":"Projects","body":"BoquilaHUB\n\n\t\n\nThe best AI tool to monitor nature\ngithub.com/boquila/boquilahub\nBoquilaVerse\n\n\t\n\nA collection of 3D models created using Gaussian Splatting, and then used for synthetic dataset creation.\nStill in development\nboquila.org/verse\nOcrisp\n\n\t\n\nOne-click RAG implementation, Simple and Portable.\ngithub.com/boquila/ocrisp\nTidierVest\nWeb scraping in Julia, based on rvest. (Faster than Beautiful Soup or Rvest)\n\npdfx\nMinimal AI-retrival info on PDFs. Returns JSON.\n\n\t\n\n\ngithub.com/jdiaz97/pdfx\nTBA\nCode quality assurance tool. For Rust and written in Rust.\n"},{"url":"https://jdiaz97.github.io/blog/","title":"Blog","body":""},{"url":"https://jdiaz97.github.io/blog/what-julia-has-that-rust-needs/","title":"What Julia has that Rust desperately needs","body":"The situation\nThe crate ffmpeg-next is a fork of the original and abandoned ffmpeg crate. Now, we have new forks like ffmpeg-the-third and rffmpeg that are more up-to-date. At the same time, ffmpeg-next is now trying to revive. So, which ffmpeg repo should I look at now? Sorry if reading that made you dizzy, but that’s how bad the situation is.\nspeculoos is a fork of the unmaintained spectral.\nThe great ort is a fork of onnxruntime-rs.\njuice is a fork of leaf.\nyaml-rust and yaml-rust2.\nserde-yaml and serde-yaml-bw.\nIt is normal for people to drop open-source software; I’m not saying they should keep working forever. But it’s sad that one person gets to gatekeep everyone else and say, “This is abandoned, I’ll keep the crate name so now you have to make a worse one or be creative.”\nAnyway, so. What if all the disorganized effort was centralized and focused?\nHow Julia solved this problem\nThe Julia community faced the exact same problem in the past. The solution is quite simple: let’s move the packages into self-organized GitHub organizations.\n\nPackages for biology? You have BioJulia\nPackages for data? You have JuliaData\nPackages for TidyVerse-inspired packages? You have TidierOrg\n\nBy doing this:\n\nThe repos won’t become inaccessible forever\nYou have other members (maybe) supporting your work\nWe get less noise (fewer forks) and more productivity\nWe get a wonderful sense of community\n\nI think governance problems can emerge if people can’t respect each other but the gains are worth considering. This is a HUGE positive for Julia, and I think Rust needs this too.\nFAQ\nQ: This is not just a Rust problem btw, every programming language has this.\nA: They should fix it too. Just talking about what I see.\n"},{"url":"https://jdiaz97.github.io/blog/ai-for-biodiversity-in-rust/","title":"Using Rust to run the most powerful AI models for Camera Trap processing","body":"An example of how AI is doing great things for the planet. This is about BoquilaHUB and how it’s helping a lot of people protect nature.\nCamera traps\nThe most important tool to monitor wildlife worldwide is camera traps. Every national park uses them.\nThe problem is that this creates a lot of data, millions of images that have to be processed somehow. The most recent and most powerful models that we can use to automate these tasks are the following:\nSpeciesNet and MegaDetector\nReleased just a few months ago, we have these two models:\n\nSpeciesNet, by Google, a classification EfficientNetV2 trained on millions of images with over 2000 classes. 55.9M parameters.\nMDv-1000 (the latest in the MegaDetector series), which is an object detection model with 3 classes: animal, person, vehicle. 140.3M parameters in its larger version.\n\nSo, we can use MegaDetector to detect animals and SpeciesNet to get close to a species classification. Great! We can get close to automating camera trap processing.\nProcessing\nWith a library, AI is very simple to run. The process is:\nInput Tensor -&gt; Run inference -&gt; Output Tensor -&gt; A data representation that’s useful for us.\nSo let’s do that. We’ll be using ort, version 2.0.0-rc.9. The API is slightly different in the rc.10 version, but the core logic is the same.\nPreprocessing\nGetting an Input Tensor:\n\nFor SpeciesNet, the input tensor needs to have the shape: NCHW.\nFor MDv-1000, the input tensor needs to have the shape: NHWC.\n\nLet’s assume we have an image loaded in memory already, and we need to transform it.\n\nAnd that’s it. From an image, we can create input tensors that work for both SpeciesNet and MegaDetector.\nInference\n\nPost-processing\nFirst, we extract the output tensor into an ndarray:\n\nNow we can process it and create a representation that’s useful for us.\nFor SpeciesNet:\n\nFor MDv-1000:\n\nCombining both models\nThe rest is just hacky work, you can imagine it very easily. For each bounding box:\n\nSlice the image.\nRun the extra classification model (SpeciesNet).\nAdd the predictions to the XYXYc struct in the extra_cls field. That’s it.\n\nThings I didn’t mention\nThere is more post-processing involved. For example:\n\n“SpeciesNet thinks the animal is a kangaroo, but my data is not from Australia”. Ok, we can use your location and “roll up” the classification up in the taxonomy level and weight the other predictions until we have a good conclusion.\n\nThat’s just hacky work, useful but not interesting to read.\nConclusion\nI think Rust makes it easy to do this. Because:\n\nEnums are great for handling different cases in a simple way. In the actual code, there is more of that.\nThe integration between ndarray and ort is very clean.\nNdarrays are great to manage. Coming from Julia and Python I’m very satisfied with using ndarray.\n\nFAQ\nQ: Bro, just deploy a Python inference endpoint using this cloud provider to avoid writing new code.\nA: Offline inference is very important for people working in national parks. Also, it would probably be very expensive if you’re producing a lot of data, and everything related to biodiversity protection is underfunded.\nQ: hey but ORT is just a wrapper for ONNX\nA: Yeah but it’s way cleaner than using ONNX from C. Also, they’re trying to turn ORT into frontend for other frameworks, like Candle.\n"},{"url":"https://jdiaz97.github.io/blog/flutter-to-egui/","title":"Why I Switched from Flutter + Rust to Rust + egui","body":"This is just a personal experience, there are no absolute truths. Like in any other blog post, a lot of the things you’ll read here could be just a skill issue, or legitimate issues. It’s up to you to decide.\nFlutter + Rust\nWe had an app that had a nice Flutter UI that called Rust binaries. The bindings were generated using flutter_rust_bridge, which is an amazing piece of software. A lot of people have built large and complex apps using this tool. It’s crazy how far it can just work, just by running:\n\nThat’s really all it takes for many, many, many cases.\nBut I got frustrated for the few times that ‘generate’ won’t work, for the times where FFI wasn’t just working, and for the times that I had to spend energy designing a public API that was 100% friendly for Rust &lt;-&gt; Flutter.\nRust + egui\nAfter some time of being frustrated with the current stack, I was thinking of dropping Flutter, I didn’t want to think about FFI anymore. I chose egui to check if it was feasible to move the UI code with very little friction. I came to know about egui because of the extremely impressive work they’ve done to build rerun. I was very motivated to try this.\nAfter rewriting most of the UI code in egui during a weekend, I decided to move and leave Flutter behind. But why?\nMinimizing complexity\nHaving 2 programming languages adds complexity. BoquilaHUB is a small software project, I don’t want it to have unnecessary complexity.\nNot all complexity is unnecessary, you do sometimes need it in order to make progress and get things done. So, how much complexity is unnecessary complexity?\nWe can measure this by looking at lines of code. In my case, ‘flutter_rust_bridge_codegen generate’ will generate a few thousand lines of code. I don’t understand this generated code, it’s not readable. Do I really want to have some code I don’t understand in my project folder? In earlier versions of the project, sometimes the amount of generated lines would be higher than the lines written by me. This balance would change depending on the API, but it’s always quite big.\nI want to understand my project, I want to understand what I’m compiling. I can’t optimize generated lines that aren’t readable and will change in mysterious ways when I change the API.\nPlaying to my strengths\nThere is only 1 programmer in the project, and that’s me. I was hoping to get funding to get an actually good GUI person who could make great use of Flutter to create a wonderful GUI experience. That didn’t happen, so the Flutter capabilities were very underused.\nFlutter:\n\nEgui:\n\nOf course, making the Flutter one look good is possible and easy if you’re good at it. I wasn’t, and egui just worked better for me. I didn’t even make an effort to make it look good; I just grabbed a minimal template and modified it, and it looks great.\nImmediate mode is a great paradigm for UI\nA quick Google search with “flutter setstate is not refreshing” reveals a struggle that you will face quite often when running Flutter. It sounds like an easy fix, but the nature of Flutter using a bunch of nested Widgets creates, naturally, lasagna code that makes it hard to reason about this.\nWhen moving to egui, I recreated the whole UI with 0 cases of this problem. It’s a different paradigm, in every frame the UI will refresh, so you don’t have to struggle. You don’t have to make complex callbacks or deal with state management frameworks like getx, provider, bloc, or whatever else there is. If you work with the paradigm and not against it, you’re done, you can make great progress.\nDo you need to add a button? In Rust:\n\nThat’s it, you will 100% see the change in your UI, no callbacks, no stateful vs stateless widgets, no googling why your UI is not refreshing. No learning a new metaframework (getx, bloc, provider, etc) for a framework (flutter) to deal with state. It just works in egui.\nPerformance\nThis is not about Rust being fast and Dart being slow. It’s about my personal appreciation that the final app in 100% Rust was faster.\nThe previous slowness maybe was a side effect of having unmonitored FFI, how much was I cloning? I don’t know. The app calls ONNX Runtime, which is written in C. This is called from Rust using ort, and before, Dart would call these binaries to let me do the inference in Flutter. Maybe all of this made the app drag a bit.\nNow it just feels faster and way more snappy.\nAnyway\nThat’s it. If you fancy AI for biodiversity, feel free to support BoquilaHUB at this link.\n"},{"url":"https://jdiaz97.github.io/","title":"Greenblog","body":"\n\t\n\nProgrammer and Environmentalist.\nTools\n\nRust: ORT, Axum, Tokio, Rayon, Ndarray, Egui, Images\nPython: PyTorch, TensorFlow, Scikit-learn, Hugging Face Transformers, Pydantic, RAG, Structured Output, FastAPI, Uvicorn, NumPy, Pandas, Polars, OpenCV, SQLAlchemy\nJulia: Type safety, Arrays, Tidier\nR: Tidyverse\nDart: Flutter\nC / C++: ONNX, OpenCV, Open3D\nSQL: PostgreSQL, MySQL, SQLite, Pgvector, Supabase\nJavaScript: Vanilla JS, Bootstrap, HTML, CSS\n\nMy guitar\nItalia Mondial Deluxe, modified\n\n\t\n\n"}]